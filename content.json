{"pages":[{"title":"about","text":"本人搭建这个博客旨在记录一点笔记以及自己所学的东西。也欢迎大家共同学习交流。 github地址:https://github.com/Wonpeach","link":"/about/index.html"}],"posts":[{"title":"(一)cpp基础笔记之初识cpp","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 C++初识第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 编写代码1234567891011#include&lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 运行程序 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明 多行注释： /* 描述信息 */ 通常放在一段代码的上方，对该段代码做整体说明 提示：编译器在编译代码时，会忽略注释的内容 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 示例： 123456789101112131415161718//1、宏常量#define day 7int main() { cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0;} 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 1提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读","link":"/2021/11/05/%E4%B8%80-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E8%AF%86cpp/"},{"title":"(七)cpp基础笔记之指针","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 指针指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： 123456789101112131415161718192021int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： 1234567891011121314151617int main() { int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0; 总结：所有指针类型在32位操作系统下是4个字节 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 12345678910111213int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 野指针：指针变量指向非法的内存空间 示例2：野指针 123456789101112int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： 12345678910111213141516171819202122232425int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0;} 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 指针和数组作用：利用指针访问数组中元素 示例： 1234567891011121314151617181920int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) { //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; } system(&quot;pause&quot;); return 0;} 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： 12345678910111213141516171819202122232425262728293031//值传递void swap1(int a ,int b){ int temp = a; a = b; b = temp;}//地址传递void swap2(int * p1, int *p2){ int temp = *p1; *p1 = *p2; *p2 = temp;}int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： 123456789101112131415161718192021222324252627282930313233343536373839//冒泡排序函数void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[]{ for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}//打印数组函数void printArray(int arr[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; }}int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0;} 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针","link":"/2021/11/06/%E4%B8%83-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%8C%87%E9%92%88/"},{"title":"(三)cpp基础笔记之运算符","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： 1234567891011121314151617181920212223242526272829//加减乘除int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：在除法运算中，除数不能为0 示例2： 1234567891011121314151617181920212223242526272829//取模int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：只有整型变量可以进行取模运算 示例3： 1234567891011121314151617181920212223242526272829//递增int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： 1234567891011121314151617181920212223242526272829303132333435363738int main() { //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： 123456789101112131415161718192021int main() { int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;} 注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 12345678910111213//逻辑运算符 --- 非int main() { int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;} 总结： 真变假，假变真 示例2：逻辑与 12345678910111213141516171819202122//逻辑运算符 --- 与int main() { int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;} 总结：逻辑与运算符总结： 同真为真，其余为假 示例3：逻辑或 12345678910111213141516171819202122//逻辑运算符 --- 或int main() { int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;} 逻辑或运算符总结： 同假为假，其余为真","link":"/2021/11/06/%E4%B8%89-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"(五)cpp基础笔记之数组","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 数组概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个数据元素都是相同的数据类型 特点2：数组是由连续的内存位置组成的 一维数组一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score2[i] &lt;&lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score3[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： 12345678910111213141516171819202122int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0;} 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 1234567891011121314151617181920212223242526int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i &lt; 9 - 1; i++) { for (int j = 0; j &lt; 9 - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 二维数组二维数组就是在一维数组上，多加一个维度。 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(&quot;pause&quot;); return 0;} 总结：在定义二维数组时，如果初始化了数据，可以省略行数 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： 12345678910111213141516171819202122232425262728int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： 12345678910111213141516171819202122232425int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; }; for (int i = 0; i &lt; 3; i++) { int sum = 0; for (int j = 0; j &lt; 3; j++) { sum += scores[i][j]; } cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; } system(&quot;pause&quot;); return 0;}","link":"/2021/11/06/%E4%BA%94-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"title":"(八)cpp基础笔记之结构体","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 结构体结构体基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 结构体定义和使用语法：struct 结构体名 { 结构体成员列表 }； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： 1234567891011121314151617181920212223242526272829303132333435363738//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数}stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = { &quot;李四&quot;,19,60 }; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体名 数组名[元素个数] = { {} , {} , ... {} } 示例： 12345678910111213141516171819202122232425262728//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数}int main() { //结构体数组 struct student arr[3]= { {&quot;张三&quot;,18,80 }, {&quot;李四&quot;,19,60 }, {&quot;王五&quot;,20,70 } }; for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 示例： 123456789101112131415161718192021222324//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};int main() { struct student stu = { &quot;张三&quot;,18,100, }; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： 123456789101112131415161718192021222324252627282930313233343536373839//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//教师结构体定义struct teacher{ //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生};int main() { struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//值传递void printStudent(student stu ){ stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;}//地址传递void printStudent2(student *stu){ stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;}int main() { student stu = { &quot;张三&quot;,18,100}; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 结构体中 const使用场景作用：用const来防止误操作 示例： 123456789101112131415161718192021222324252627//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作{ //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;}int main() { student stu = { &quot;张三&quot;,18,100 }; printStudent(&amp;stu); system(&quot;pause&quot;); return 0;} 结构体案例案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Student{ string name; int score;};struct Teacher{ string name; Student sArray[5];};void allocateSpace(Teacher tArray[] , int len){ string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } }}void printTeachers(Teacher tArray[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) { cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; } }}int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0;} 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： 12345{&quot;刘备&quot;,23,&quot;男&quot;},{&quot;关羽&quot;,22,&quot;男&quot;},{&quot;张飞&quot;,20,&quot;男&quot;},{&quot;赵云&quot;,21,&quot;男&quot;},{&quot;貂蝉&quot;,19,&quot;女&quot;}, 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//英雄结构体struct hero{ string name; int age; string sex;};//冒泡排序void bubbleSort(hero arr[] , int len){ for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j].age &gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}//打印数组void printHeros(hero arr[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; }}int main() { struct hero arr[5] = { {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0;}","link":"/2021/11/06/%E5%85%AB-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"},{"title":"(二)cpp基础笔记之数据类型","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 整型作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) sizeof关键字作用：利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： 1234567891011121314int main() { cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 整型结论：short &lt; int &lt;= long &lt;= long long 实型（浮点型）作用：用于表示小数 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 12345678910111213141516171819202122int main() { float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 字符型作用：字符型变量用于显示单个字符 语法：char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： 1234567891011121314151617int main() { char ch = 'a'; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = 'abcde'; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0;} ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 转义字符作用：用于表示一些不能显示出来的ASCII字符 现阶段我们常用的转义字符有：\\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 *\\* 代表一个反斜线字符”” 092 ‘ 代表一个单引号（撇号）字符 039 “ 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： 1234567891011int main() { cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： 123456789int main() { char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： 123456789int main() { string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C++风格字符串，需要加入头文件#include 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占1个字节大小 示例： 1234567891011121314int main() { bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0;} 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 12345678910111213141516171819202122232425262728293031323334int main(){ //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;}","link":"/2021/11/06/%E4%BA%8C-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"(六)cpp基础笔记之函数","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 函数概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 12345678返回值类型 函数名 （参数列表）{ 函数体语句 return表达式} 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 123456//函数定义int add(int num1, int num2){ int sum = num1 + num2; return sum;} 函数的调用功能：使用定义好的函数 语法：函数名（参数） 示例： 12345678910111213141516171819202122232425//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参{ int sum = num1 + num2; return sum;}int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参 示例： 12345678910111213141516171819202122232425262728293031void swap(int num1, int num2){ cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return}int main() { int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结： 值传递时，形参是修饰不了实参的 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： 123456789101112131415161718192021222324252627282930//函数常见样式//1、 无参无返void test01(){ //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用}//2、 有参无返void test02(int a){ cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;}//3、无参有返int test03(){ cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10;}//4、有参有返int test04(int a, int b){ cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum;} 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： 123456789101112131415161718192021//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b){ return a &gt; b ? a : b;}int main() { int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： 123456789101112131415161718192021222324252627282930//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b);//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b){ int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;}//main函数文件#include &quot;swap.h&quot;int main() { int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0;}","link":"/2021/11/06/%E5%85%AD-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"hexo 模板","text":"高级设置（1）模板设置当我们使用命令 hexo new &quot;title&quot; 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化。 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯。 一个简单的示例如下： 1234title: {{ title }}date: {{ date }}tags: categories: （2）头部设置在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部 文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等 一个简单的示例如下： 1234title: Titledate: YYYY-MM-DD HH:MM:SStags: [tag1, tag2, ...]categories: category 注意：属性和属性值之间必须有一个空格，否则会解析错误 （3）首页显示在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容 如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简 这时，我们只需在文章中使用 &lt;!--more--&gt; 标志即可，表示只会显示标志前面的内容。","link":"/2021/11/22/hexo-%E6%A8%A1%E6%9D%BF/"},{"title":"(四)cpp基础笔记之程序流程结构","text":"写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 程序流程结构C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 选择结构if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 ​ 单行格式if语句：if(条件){ 条件满足执行的语句 } 示例： 12345678910111213141516171819202122int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 注意：if条件表达式后不要加分号 多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例： 123456789101112131415161718192021int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例： 1234567891011121314151617181920212223 int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) { cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; } else if (score &gt; 650) { cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; } } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 123456789101112131415161718192021int main() { int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 switch语句作用：执行多条件分支语句 语法： 12345678910111213switch(表达式){ case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break;} 示例： 12345678910111213141516171819202122232425262728293031323334int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) { case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0;} 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 循环结构while循环语句作用：满足循环条件，执行循环语句 语法：while(循环条件){ 循环语句 } 解释：只要循环条件的结果为真，就执行循环语句 示例： 12345678910111213int main() { int num = 0; while (num &lt; 10) { cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; } system(&quot;pause&quot;); return 0;} 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：猜数字 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do{ 循环语句 } while(循环条件); 注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件 示例： 12345678910111213141516int main() { int num = 0; do { cout &lt;&lt; num &lt;&lt; endl; num++; } while (num &lt; 10); system(&quot;pause&quot;); return 0;} 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 for循环语句作用： 满足循环条件，执行循环语句 语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： 1234567891011int main() { for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： 12345678910111213141516int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 跳转语句break语句作用: 用于跳出选择结构或者循环结构 break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： 12345678910111213141516171819202122232425262728int main() { //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) { case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0;} 示例2： 123456789101112131415int main() { //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 示例3： 12345678910111213141516171819int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { if (j == 5) { break; } cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} continue语句作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： 123456789101112131415int main() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { continue; } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 注意：continue并没有使整个循环终止，而break会跳出循环 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： 123456789101112131415161718int main() { cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：在程序中不建议使用goto语句，以免造成程序流程混乱","link":"/2021/11/06/%E5%9B%9B-cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/11/01/hello-world/"},{"title":"Cpp基础笔记","text":"0.写在前面 本笔记是来自黑马程序员的C++入门基础，本篇笔记视频讲解地址：https://www.bilibili.com/video/BV1et411b73Z?p=1 本笔记主要用来复习回顾使用。 这里是cpp基础的合集，觉得太多的可以分P看其他笔记。 1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码1234567891011#include&lt;iostream&gt;using namespace std;int main() { cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明 多行注释： /* 描述信息 */ 通常放在一段代码的上方，对该段代码做整体说明 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 示例： 123456789101112131415161718//1、宏常量#define day 7int main() { cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0;} 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 1提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： 1234567891011121314int main() { cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 整型结论：short &lt; int &lt;= long &lt;= long long 2.3 实型（浮点型）作用：用于表示小数 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 12345678910111213141516171819202122int main() { float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： 1234567891011121314151617int main() { char ch = 'a'; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = 'abcde'; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0;} ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些不能显示出来的ASCII字符 现阶段我们常用的转义字符有：\\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 *\\* 代表一个反斜线字符”” 092 ‘ 代表一个单引号（撇号）字符 039 “ 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： 1234567891011int main() { cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： 123456789int main() { char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： 123456789int main() { string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：C++风格字符串，需要加入头文件#include 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占1个字节大小 示例： 1234567891011121314int main() { bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0;} 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 12345678910111213141516171819202122232425262728293031323334int main(){ //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;} 3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： 1234567891011121314151617181920212223242526272829//加减乘除int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：在除法运算中，除数不能为0 示例2： 1234567891011121314151617181920212223242526272829//取模int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：只有整型变量可以进行取模运算 示例3： 1234567891011121314151617181920212223242526272829//递增int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： 1234567891011121314151617181920212223242526272829303132333435363738int main() { //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： 123456789101112131415161718192021int main() { int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;} 注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 12345678910111213//逻辑运算符 --- 非int main() { int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0;} 总结： 真变假，假变真 示例2：逻辑与 12345678910111213141516171819202122//逻辑运算符 --- 与int main() { int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;} 总结：逻辑与运算符总结： 同真为真，其余为假 示例3：逻辑或 12345678910111213141516171819202122//逻辑运算符 --- 或int main() { int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0;} 逻辑或运算符总结： 同假为假，其余为真 4 程序流程结构C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件){ 条件满足执行的语句 } 示例： 12345678910111213141516171819202122int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 注意：if条件表达式后不要加分号 多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例： 123456789101112131415161718192021int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例： 1234567891011121314151617181920212223 int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) { cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; } else if (score &gt; 650) { cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; } } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 123456789101112131415161718192021int main() { int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： 12345678910111213switch(表达式){ case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break;} 示例： 12345678910111213141516171819202122232425262728293031323334int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) { case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0;} 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法：while(循环条件){ 循环语句 } 解释：只要循环条件的结果为真，就执行循环语句 示例： 12345678910111213int main() { int num = 0; while (num &lt; 10) { cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; } system(&quot;pause&quot;); return 0;} 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：猜数字 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do{ 循环语句 } while(循环条件); 注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件 示例： 12345678910111213141516int main() { int num = 0; do { cout &lt;&lt; num &lt;&lt; endl; num++; } while (num &lt; 10); system(&quot;pause&quot;); return 0;} 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： 1234567891011int main() { for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： 12345678910111213141516int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句4.3.1 break语句作用: 用于跳出选择结构或者循环结构 break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： 12345678910111213141516171819202122232425262728int main() { //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) { case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0;} 示例2： 123456789101112131415int main() { //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 示例3： 12345678910111213141516171819int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { if (j == 5) { break; } cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 4.3.2 continue语句作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： 123456789101112131415int main() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { continue; } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： 123456789101112131415161718int main() { cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个数据元素都是相同的数据类型 特点2：数组是由连续的内存位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score2[i] &lt;&lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score3[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： 12345678910111213141516171819202122int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0;} 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 1234567891011121314151617181920212223242526int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i &lt; 9 - 1; i++) { for (int j = 0; j &lt; 9 - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(&quot;pause&quot;); return 0;} 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： 12345678910111213141516171819202122232425262728int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： 12345678910111213141516171819202122232425int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; }; for (int i = 0; i &lt; 3; i++) { int sum = 0; for (int j = 0; j &lt; 3; j++) { sum += scores[i][j]; } cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 12345678返回值类型 函数名 （参数列表）{ 函数体语句 return表达式} 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 123456//函数定义int add(int num1, int num2){ int sum = num1 + num2; return sum;} 6.3 函数的调用功能：使用定义好的函数 语法：函数名（参数） 示例： 12345678910111213141516171819202122232425//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参{ int sum = num1 + num2; return sum;}int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参 示例： 12345678910111213141516171819202122232425262728293031void swap(int num1, int num2){ cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return}int main() { int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： 123456789101112131415161718192021222324252627282930//函数常见样式//1、 无参无返void test01(){ //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用}//2、 有参无返void test02(int a){ cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;}//3、无参有返int test03(){ cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10;}//4、有参有返int test04(int a, int b){ cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum;} 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： 123456789101112131415161718192021//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b){ return a &gt; b ? a : b;}int main() { int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： 123456789101112131415161718192021222324252627282930//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b);//swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b){ int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;}//main函数文件#include &quot;swap.h&quot;int main() { int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0;} 7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： 123456789101112131415161718192021int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： 1234567891011121314151617int main() { int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0; 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 12345678910111213int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 野指针：指针变量指向非法的内存空间 示例2：野指针 123456789101112int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： 12345678910111213141516171819202122232425int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0;} 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： 1234567891011121314151617181920int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) { //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; } system(&quot;pause&quot;); return 0;} 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： 12345678910111213141516171819202122232425262728293031//值传递void swap1(int a ,int b){ int temp = a; a = b; b = temp;}//地址传递void swap2(int * p1, int *p2){ int temp = *p1; *p1 = *p2; *p2 = temp;}int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： 123456789101112131415161718192021222324252627282930313233343536373839//冒泡排序函数void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[]{ for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}//打印数组函数void printArray(int arr[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; }}int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0;} 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体8.1 结构体基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 { 结构体成员列表 }； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： 1234567891011121314151617181920212223242526272829303132333435363738//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数}stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = { &quot;李四&quot;,19,60 }; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体名 数组名[元素个数] = { {} , {} , ... {} } 示例： 12345678910111213141516171819202122232425262728//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数}int main() { //结构体数组 struct student arr[3]= { {&quot;张三&quot;,18,80 }, {&quot;李四&quot;,19,60 }, {&quot;王五&quot;,20,70 } }; for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; } system(&quot;pause&quot;); return 0;} 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 示例： 123456789101112131415161718192021222324//结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};int main() { struct student stu = { &quot;张三&quot;,18,100, }; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： 123456789101112131415161718192021222324252627282930313233343536373839//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//教师结构体定义struct teacher{ //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生};int main() { struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//值传递void printStudent(student stu ){ stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;}//地址传递void printStudent2(student *stu){ stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;}int main() { student stu = { &quot;张三&quot;,18,100}; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： 123456789101112131415161718192021222324252627//学生结构体定义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数};//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作{ //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;}int main() { student stu = { &quot;张三&quot;,18,100 }; printStudent(&amp;stu); system(&quot;pause&quot;); return 0;} 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Student{ string name; int score;};struct Teacher{ string name; Student sArray[5];};void allocateSpace(Teacher tArray[] , int len){ string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } }}void printTeachers(Teacher tArray[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) { cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; } }}int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0;} 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： 12345{&quot;刘备&quot;,23,&quot;男&quot;},{&quot;关羽&quot;,22,&quot;男&quot;},{&quot;张飞&quot;,20,&quot;男&quot;},{&quot;赵云&quot;,21,&quot;男&quot;},{&quot;貂蝉&quot;,19,&quot;女&quot;}, 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//英雄结构体struct hero{ string name; int age; string sex;};//冒泡排序void bubbleSort(hero arr[] , int len){ for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j].age &gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } }}//打印数组void printHeros(hero arr[], int len){ for (int i = 0; i &lt; len; i++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; }}int main() { struct hero arr[5] = { {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0;}","link":"/2021/11/05/Cpp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"title":"","text":"Deep learning on mobile devices: A review(移动设备上的深度学习—综述)移动设备上实现深度学习的优点包括通信带宽低，云计算资源成本小，响应时间短，数据私密性好。 深度学习和推理在移动设备上的优势有四个方面:1)节省通信带宽。在移动设备上完成的计算越多，发送到云端的数据就越少。2)降低云计算资源成本。对于某些应用程序来说，维护甚至租用云计算资源的成本可能令人望而却步。随着移动设备的计算能力越来越强，移动设备上的计算成为可能。3)响应时间快。如果所有计算都能在本地执行，那么就不会有通信时间的开销，也不会有服务器可靠性的问题。对于某些应用程序，例如医疗保健和军事领域，此响应时间非常关键。4)移动计算将感知数据保存在本地设备上，大大提高了用户数据的隐私性。对于家庭机器人应用来说尤其如此。 1.移动深度学习硬件架构1.CPU 使用高度优化的线性代数库LAPACK/BLAS，大多数现有的深度学习框架已经考虑到这一点[1]; 充分利用多核多线程cpu进行并行计算; 利用CPU厂商专用的数学库; 对模型大小、数值精度、计算速度和系统性能进行权衡研究 2.GPUs and Mobile GPUs ​ GPU在物理设计上是一种高度并行的处理器。它通常包含数千个重复的小核，这使得在矩阵上执行某些类型的重复计算比一般用途的cpu效率更高。 3.FPGA ​ CPU是用于非常通用的计算，ASIC几乎是专门用于特定的应用，而FPGA则介于两者之间。fpga可以被“固件”(重新)编程，以非常高效地执行许多特定的应用程序。它在系统开发时间和功耗方面也处于中间位置。 4.ASIC和TPU ​ ASIC在为应用设计和制造特定芯片方面比FPGA更进一步。它有潜力实现更好的SWAP(尺寸、质量与功耗)，但代价是长期的开发时间。许多模拟、数字、混合信号、忆阻和尖峰电路被设计来模拟听觉、视觉和大脑功能。有许多asic是为人工智能应用开发的。​ TPU是谷歌专门为神经网络机器学习开发的。它被使用在最近的AlphaGo对李世石的人机围棋比赛中。虽然没有商业可用，但TPU提供给机器学习研究人员免费试用，并可通过其云计算服务访问。 5.移动深度学习的CPU、GPU、FPGA、ASIC比较 ​ 如前所述，CPU和GPU是通用计算平台，因此提供了最大的灵活性。深度学习应用的早期算法性能研究应该利用cpu和gpu来初步了解可达到的性能。cpu和gpu支持全精度计算，可以提供计算密集型模型，这通常意味着可以实现更高的预测精度。但是，gpu和cpu的能效较低。asic可以更节能，因为硬件是专门为特定的计算而设计的。然而，ASIC芯片的设计和开发可能非常耗时。因此，只有当算法研究已经确定，系统的功耗预算非常低时，才使用专用集成电路。fpga提供了功耗、预测精度和系统开发速度之间的折中。 2.移动深度学习平台和库2.1利用云人工智能服务构建移动深度学习解决方案​ 如果云上的深度学习适合应用程序，那么在移动设备上部署深度学习能力的最快方法就是利用许多现有的云人工智能api。在这种情况下，移动设备充当传感器和用户界面。这些api在机器学习、语音识别、计算机视觉、自然语言处理、人工智能助手、知识发现、个性和情感分析以及搜索等方面提供了随时可用的人工智能能力。​ 一些深度学习应用程序，或者至少是推理部分，需要在移动设备上实现，而不依赖于云机器学习。许多深度学习平台仍可用于移动应用程序。以下是一些最著名的移动深度学习平台: TensorFlow Lite来自谷歌:TensorFlow是谷歌Brain团队开发的一个开源工具，用于深度学习模型的训练和部署。其灵活的架构允许部署到各种平台，从CPU, GPU, TPU，移动和边缘设备。对于初学者来说，Keras是一个简单的python API，可以使用TensorFlow来构建模型和运行评估。TensorFlow Lite是在移动和嵌入式设备上运行TensorFlow模型的解决方案。它经过了精确、低延迟、小模型尺寸和可移植到Android、iOS和其他物联网(IoT)设备的优化。 来自Facebook的Caffe2:Caffe2是一个轻量级的、模块化的、可扩展的深度学习框架。它提供跨平台库，用于在云或移动设备上部署。Caffe模型可以小于1MB的二进制大小，并且是为了提高速度而构建的。支持ARM CPU, iPhone GPU, Android GPU。此外，它还支持导入使用CNTK和PyTorch训练的模型。 Core ML for IOS: Core machine learning是苹果公司为IOS 11开发的。它建立在低级原语之上:加速基本神经网络子程序(BNNS)，金属性能着色器(MPS)自动最小化内存占用和功耗。它直接支持Keras, Caffe, scikit -learn, XGGoost和LibSVM机器学习工具[Keras, Caffe, scikit, XGGoost, LibSVM]。此外，使用Caffe和TensorFlow模型构建的模型可以在几行代码中转换为CoreML模型。 高通骁龙神经处理SDK:它被设计用于运行在高通骁龙移动平台上的Caffe，Caffe2,ONNX，或TensorFlow训练的DNN模型。它能自动识别出最佳的目标核进行推理，无论是CPU、GPU还是DSP,如今大约有一半的安卓手机使用了Snapdragon芯片。 DeepLearningKit for Apple Devices: DeepLearningKit是一个DL框架，适用于电视(TV)、iOS (iPhone和iPad)和OS X (MacBook和iMac)。它支持CNN在Caffe训练的模型。它运行在移动GPU上。它是快速的，但自2016年以来就没有维持过。 MACE (Mobile AI Compute Engine): MACE是针对移动异构计算平台优化的深度学习推理框架。它不仅支持广泛的模型形成，如TensorFlow、Caffe和ONNx，而且还具有保护模型的技术，如将模型转换为c++代码。它优化了运行时、内存使用、库占用和UI响应。 Paddle-Mobile: Paddle-Mobile是一个更大的深度学习项目PaddlePaddle的一部分，专注于嵌入式平台。支持ARM CPU、Mali GPU、Android GPU/GPU、iOS、基于fpga的开发板、Raspberry Pi等ARM- linux开发板。 支持IOS移动系统的：TensorFlow 、Caffe2、CoreML、DeepLearningKit 支持Android移动系统的：TensorFlow、Caffe2、Snapdragon 2.2移动深度学习库 Keras。 一些深度机器学习工具包，如TensorFlow，要求用户具有非常好的机器学习和软件工程知识。同时具备这两种技能的用户非常有限，因此ML的采用非常缓慢。Keras的想法是极大地简化DL的学习和部署。通过设计一个易于使用的高级API并隐藏所有不必要的机器学习和软件细节，Keras python允许用户使用TensorFlow、CNTK或Theano，而无需通过学习曲线来详细研究每个底层库。Keras代码和文档可以在https://keras.io/上找到。Keras项目非常成功，现在已经完全集成到TensorFlow中了。Keras是最受初学者和深度学习研究人员欢迎的工具之一。在github上有许多用Keras实现的开源深度学习项目。 Torch/PyTorch。PyTorch是一个基于Torch的Python开放源码ML库。Torch本身是一个基于Lua编程语言的机器学习和科学计算的开源工具。虽然Torch已不再积极开发，但PyTorch在学术研究人员中非常受欢迎。还有许多基于PyTorch设计的开源项目和人工智能应用程序。Pytorch可在https://pytorch.org/上找到。 MXNet。MXNet来自Apache软件基金会。MXNet是一个灵活、高效的深度学习库。它将所有代码打包在一个源文件中。它的优势在于跨平台(iOS和android)，易于移植，并且适用于大多数主要编程语言。仅支持CPU部署。MXNet的网址是https://mxnet.incubator.apache.org。 CNNDroid。CNNDroid是一个开源库，用于加速CNN在Android设备上的执行。GPU加速cnn for Android支持Caffe、Torch和Theano模型，在AlexNet上使用GPU模型比CPU加速30~40倍。CNNDroid可以在https://github.com/ENCP/CNNdroid上找到。 JaveScript Libraries 。javascript是基于web应用程序的核心编程语言之一。有相当多的JavaScript库是专门为在web浏览器中进行深度学习开发而设计的，包括ConvNetJS、DeepLern.js、Keras.js、TensorFlow.js、Brain.js等。不需要安装很多库或驱动程序。这些库对于构建移动深度学习演示非常方便。这也使得移动机器学习更具互动性。其中一些只用于DNN推断，而其他的也具有训练DNN的能力。有些可以使用CPU进行训练和推断，如ConvNetJs。其他的可以使用GPU进行训练和推理，如DeepLearn.js。js在支持GPU的浏览器中运行Keras模型。对于在现有平台和库中拥有足够经验的开发者来说，开发一个移动深度学习原型可能需要几周或几个月的时间。下一步是在字段中测试应用程序。实际的测试可能会发现计算、存储、内存占用或SWAP方面需要进一步改进。特别是，当系统收集更多特定领域的数据时，您可能能够提高深度学习系统的性能。ML设计者需要对深度学习算法和软件有更深入的了解，才能将其性能提升到更高的水平。 ​ 每一组深度机器学习库和工具都有自己的优点、缺点和用例。使用这些工具训练的模型都有自己的格式。为了充分利用所有这些工具和库，能够将模型格式从一种转换为另一种可能是有益的。因此，为此目的开发了一些项目。最强大的模型转换工具之一是MMdnn。该工具可以将TensorFlow、CNTK、Keras、Caffe、PyTorch、MXNet和CoreML格式模型转换为中间表示，然后可以将中间表示转换为这些原生目标格式[28]之一。 3.移动深度学习优化在软件、算法、软硬件联合设计等方面，优化移动深度学习应用的SWAP性能。 3.1 DeepX软件加速器​ DeepX就是一个软件加速器，专为移动设备[43]上的低功耗深度学习推理而设计。该算法由两种用于深度学习推理的资源控制算法组成。一种算法将DNN体系结构分解成各种类型的块，这些块在异构的本地GPU和CPU处理器上更有效地执行。另一种算法通过资源缩放来调整DNN模型结构，从而调整每个块的开销。 3.2 SWAP的算法优化​ 深入研究机器学习神经网络的最初动机是为了获得更好的表征学习。这些学习的表示捕获了特征空间中复杂的非线性嵌入，使模型具有更好的准确性和泛化性能。这些模型通常是深度的，包含数百万个参数，通常不适合移动深度学习部署。最近，人们做了一些非常有趣的工作，使这些高精度模型更适合于移动应用程序，几乎或不牺牲准确性。下面一些方法总结了其中的一些思想，包括dnn的量化、剪枝、压缩和近似。 3.2.1 CNN架构优化​ 最近的ResNet使数百层以上的DNN训练取得了令人印象深刻的准确性。然而，精度性能并不与层数成线性关系。对于移动应用程序，在选择架构以平衡准确性和其他SWAP考虑方面可以做出很好的权衡。Iandola的SqueezeNet工作提出了三种策略来优化CNN，使其参数更少[4]: 将大部分3x3滤波器替换为1x1滤波器。 减少滤波器的输入通道数量 在网络的后期层中向下采样 ​ 在ImageNet任务上，只需50倍的参数，SqueezeNet就能达到AlexNet级别的精度。通过附加的模型压缩技术(详见下文小节)，SqueezeNet实现了0.5MB大小，比AlexNet小500倍以上。 3.3.2修剪，量化和霍夫曼编码​ Han的“深度压缩”工作采用了剪枝、量化和Huffman编码技术，在不影响精度[44]的情况下，将模型大小减少了35~49倍。修剪基本上删除了所有小权重连接。通常，使用剪枝可以将权重参数减少10倍。接下来的步骤是量化和重量共享。其思想是将所有具有相似值的权值聚在一起，并将这些权值存储在一个码本中。最后一步应用众所周知的Huffman编码将更短的代码分配给更常见的符号。​ 对于移动应用程序来说，将精度从32位降低到16位或更低也是一种常见的做法。本文对不动点近似、动态不动点近似、小浮点近似和无乘子算法等不同的近似方法进行了比较。一个名为Ristretto的近似框架是用开源代码提出的。TensorFlow还支持8位量化。 3.2.3网络二值化和xnor网络量化的一种极端情况是二值化，即权重减少到-1或+1。卷积计算基本上就是求和和减法。在XNOR网络中，滤波器和卷积层的输入都是二进制[46]。与传统的32位分辨率计算相比，这种方法节省了32倍的内存，提高了58倍的卷积运算速度。在Image-Net分类上进行评价时，二元权重网络版本的AlexNet获得了与全精度Alex-Net相同的精度。作者还提供了代码。 3.3软硬件协同设计上一小节展示了移动深度学习SWAP改进的算法进步的巨大前景。采用算法和硬件协同设计的方法制作用于移动深度学习的ASIC芯片，还可以实现更大的改进。例如，Han、Liu等人最近的ASIC协同设计工作，在能效方面分别比CPU和GPU提高了4个和3个数量级。在九个DNN基准测试[47]上，它的速度比CPU和GPU分别提高了两个和一个数量级。 3.4使用特定领域数据改进移动深度学习系统性能对于深度机器学习来说，数据可能和算法一样重要。花在收集正确数据上的努力比花在改进算法上的努力更有回报，这种情况并不少见。下面的小节给出了如何处理特定领域数据的一些指导。 虽然有大量公开可用的数据集，但移动深度学习应用可能在不同的环境下运行，使用不同的传感器，或有不同的规格。从移动深度学习应用程序将要部署的环境中收集一些真实的数据总是一个好主意。这些数据对于改进模型或验证应用程序性能是非常宝贵的。然而，使用新数据从头构建模型并不总是最好的方法。对于移动深度学习来说，对环境的控制较少，因此测试数据的可变性较大。这意味着要有一个性能良好的模型，可能需要一个庞大的训练数据集。不幸的是，数据收集和数据标记可能非常耗时。考虑到所有这些因素，采取的典型步骤是: 1.搜索与应用程序相似的预先训练过的模型。对于计算机视觉、语音识别和自然语言处理等典型的人工智能应用，已经有许多高质量的模型可供公开使用。现有AI应用模型的详细列表请参见4.4节。2.对特定领域数据的预训练模型进行微调。3.利用现有框架来部署应用程序。 利用现有的模型和框架可以节省大量的工作。然而，决定预训练模型的哪个部分需要调整是一件非常困难的事情。这取决于所获取的领域特定数据的数量，以及该数据与用于构建预训练模型的原始数据之间的相似性。下表给出了一般的指导方针。 ​ 如何利用现有的域外模型提高域数据性能的一般指导 领域数据大小 与预先训练的模型数据相似 如何提升 大 高 微调N/最后一层 小 高 微调可能会过度拟合模型，在(N-1)层激活上训练线性分类器 小 低 在低层激活时训练线性分类器，高层更具体于原始数据 大 低 使用特定领域的数据从头开始训练DNN 4.面向从业者的移动深度学习资源4.1用于移动深度学习的计算机语言实现移动深度学习的不同方法需要不同的平台、工具和编程语言。这些语言提供了不同的开发效率和实际计算效率。因此，在不同的发展阶段可以采取不同的方法。此外，要在不同的硬件平台上部署已开发的系统，还需要额外的计算机语言技能。例如，Android和iOS平台使用不同的计算机语言。 4.2移动设备上的深度学习的开放源代码库移动深度学习领域的准入门槛相对较低，因为大多数研究人员都在网上免费提供他们的源代码。最受欢迎的托管源代码的网站是github。在其他情况下，机器学习社区会提供基于不同平台或库的相同算法的多个版本。在这种情况下，比较评分以及算法的文档和维护情况通常是一个好主意。 4.3深度学习模型动物园如前一节所述，有许多公开的深度学习模型。这些模型为开发移动深度学习应用程序提供了一个良好的起点。下面列出了一些模型动物园。 TensorFlow / Keras模型动物园。这可以说是最大的动物园模型。它包含两个类别，一个用于TensorFlow官方模型，另一个用于TensorFlow研究模型。官方模型使用TensorFlow的高级API，并且倾向于更好地维护和测试，以跟上TensorFlow的最新更新。官方的模型非常宽泛。例如，官方模型的Keras版本包含以下DNN架构:Xception、Vgg、ResNet、InceptionResNet、MobileNet、DenseNet和NASNet。研究模型是使用TensorFlow实现的一些最新的dnn。例如:注意力模型、生成对手模型、深度演讲和变换器。它们是由个别研究人员维护的。模型链接是https://github.com/TensorFlow/models 微软的认知工具。该工具包提供了60多个模型，涵盖了语音、图像、文本、金融、时间序列和强化学习等应用领域。链接是https://www.microsoft.com/enus/cognitive-toolkit/features/model-gallery/ Caffe/Caffe2模型动物园。Caffe预训练模型涵盖了图像处理和计算机视觉领域最具影响力的几十个模型，如CNN、VGG、ResNet等。链接是https://github.com/BVLC/caffe/wiki/Model-Zoo和https://github.com/caffe2/models/ 动物园MXNet模型。除了一些最流行的模型也涵盖其他动物园，这个动物园包含网络中的网络模型，单镜头检测模型，LocationNet，电影评级模型，和视频游戏模拟器。链接是https://mxnet.incubator.apache.org/model_zoo/index.html 4.4移动深度学习平台性能基准(IOS、Android)现代智能手机能够提供超过100亿次的浮点运算能力。移动深度学习的基准应该考虑准确性、模型大小和速度/执行时间等指标。一个基准是比较iPhone 7上用于图像分类的各种深度学习模型。下总结了性能。 ​ 基准图像分类模型性能iPhone 7 模型架构 Top1 Acc (%) 模型大小(MB) 执行时间(ms) vgg16 71 553 208 inception v3 78 95 90 ResNet 50 75 103 64 mobilenet 71 17 32 sqeezenet 57 5 24 第二个是Android智能手机上的4个芯片组(高通、HiSillicon、MediaTck和三星)的人工智能基准测试。本文将深度学习中的8个任务作为人工智能基准进行了比较，包括图像分类、人脸识别、去模糊、超分辨率、分割和增强。这个基准测试从超过10,000个移动设备和超过50个不同的移动soc中获得了结果。详情请见http://aibenchmark.com/。其中一些结论如下: 在Android上使用深度学习最简单的方法是使用TensorFlow Mobile框架。 TensorFlow Lite是一个选项，但我们推荐用于比图像分类更复杂的任务。 对于特定的设备或SoC，可以使用专有SDK，但不那么容易和方便。 Caffe 2和其他框架没有那么流行，几乎没有教程和问题描述。 模型量化的适用性有限，性能可能不可靠。 5.移动深度学习应用5.1机器人随着人工智能技术的发展，机器人在不久的将来将扮演许多科学家和工程师所设想的角色。除了前面提到的语音、自然语言处理和计算机视觉任务外，机器人还面临一些学习、推理和实施的特定应用任务。一些最新的技术综述和关于其潜力和局限性的讨论是可以得到的。要想取得进展，一个关键技术是让机器人能够自主地从感官数据中获得技能。机器人需要能够在没有特定指令的情况下完成一般任务。这也被称为学会学习。 5.2自动驾驶自动驾驶是移动深度学习的另一个非常重要的应用，有望在不久的将来成为现实。关于深度学习在自动驾驶中的应用，最近发表了许多有趣的论文。CNN对高速公路行驶的经验评价显示了其对地面和车辆的实时检测能力。提出了一个基于统一架构的多网络，用于联合分类、检测和语义分割的实时求解。自动驾驶的障碍除了道德和法律等非技术问题外，似乎还包括在极端条件下驾驶。 5.3医疗虽然医疗资源可能有限，但智能手机设备在全球日益普及。将深度学习应用于改善医疗保健服务，可能会对福祉和经济产生深远影响。拥有如此多的内置传感器，智能手机可以被用作“医疗”设备，监测个人的身体和心理状态。例如，在对话中使用音频和文本可以检测抑郁。此外，摄像机和扬声器可以作为眼睛和声音，为视力和语言障碍的人。 5.4生物识别技术与模式识别的许多其他领域的问题类似，深度学习是许多生物识别模式的领先解决方案，包括人脸、声音、按键、指纹、手指静脉、虹膜和手势识别。由于智能手机包含如此多的用户隐私数据，安全性非常重要。大多数智能手机都有内置的指纹或面部识别生物识别技术。我们可以预见，对于未来的可共享自动驾驶汽车，出于安全考虑，移动生物识别组件也应该是必须的。在一定程度上，生物特征识别是合作对象近距离协作的一个亟待解决的问题。未解决的关键问题之一是远距离不合作的主体。 5.5个人辅助、移动多媒体、增强现实和娱乐个人辅助、移动多媒体和人的互动可以说是移动深度学习技术应用最广泛的领域。最近的一份报告显示，超过4700万美国成年人已经拥有智能音箱，更不用说智能手机上的个人辅助功能了。人工智能在未来能够生成文本、图像，甚至视频。娱乐内容交付、用户粘性和增强现实都可以通过AI技术得到改善。 5.6防御随着人工智能技术的发展，它为国防工业打开了应用的大门。半自主无人机可能会使用一些类似于自动驾驶的技术来开发。许多计算机视觉技术可用于自动目标检测、识别和跟踪。深度学习适用于电子战感知的全光谱。大多数为民用机器人开发的技术可能适用于国防领域，用于军用物资的运输和其他任务。不管技术准备水平如何，科学家、工程师、媒体和政治家在推广人工智能用于自动武器时都应该非常小心。许多道德、法律、监管和政策问题尚未解决。 6.移动深度学习的挑战和未来的工作6.1用于移动设备的自动深度机器学习如前所述，移动设备应用程序的深度学习必须针对SWAP进行优化。深度学习系统中有许多可以优化的层次参数。这些被称为超参数。超参数优化是一个被称为自动机器学习的活跃课题。一些自动ML技术可以应用到移动应用中。移动DL的目标函数不仅仅是精度，还可以是精度、内存占用、计算速度和功耗的加权函数。 6.2低质量数据和ML用于信号处理移动应用程序通常意味着应用程序的约束更少。与在实验室中收集的控制良好的数据不同，移动数据往往带有更多混杂因素，更加嘈杂。这也意味着一些(如果不是很大一部分的话)标记的数据可能是错误的。虽然DNN在训练数据较大时对噪声标签具有鲁棒性，但如果训练数据较少，则会出现问题。因此，移动深度学习工程师需要更仔细地准备用于模型训练的数据。有时可能需要自定义信号处理来处理某些特殊现象。 6.3训练数据少，样本学习少，迁移学习虽然未标记的数据可能更丰富，但移动应用程序通常一开始就拥有较少的训练数据。为了启动系统，可以使用少量样本学习或迁移学习。随着可用数据的增加，初始模型可以迭代地改进。 6.4环境的改变、在线适应和终身学习移动深度学习的另一个更具挑战性的问题是，环境可能会随着时间而改变。在一些极端情况下，系统可能不得不面对一些不可预见的情况。这些情况要求移动系统能够在线适应数据的变化或能够终身学习。 6.5移动深度学习中的隐私问题由于一些移动深度学习直接处理用户的个人数据，隐私是一个问题。如果数据是在云中存储和处理的，这一点尤其正确。最近提出了一种混合深度学习架构，用于保护隐私的移动分析。","link":"/2021/11/01/notes-for-review1/"},{"title":"","text":"了解了增量学习和锚框的概念。 增量学习在传统分类任务中，为了保证训练得到的分类模型具有准确性和高可靠性，由两个基本假设:1.学习的训练样本和新的测试样本满足独立同分布2.必须有足够可用的训练样本 增量学习的能力就是能够不断地处理现实世界中连续的信息流,在吸收新知识的同时保留甚至整合 优化旧知识的能力。 造成灾难性遗忘的一个主要原因是 传统模型假设数据分布是固定或平稳的,训练样本是独立同分布的 ,所以模型可以一遍又一遍地看到所有任务相同的数据,但当数据变为连续的数据流时,训练数据的分布就是非平稳的,模型从非平稳的数据分布中持续不断地获取知识时,新知识会干扰旧知识,从而导致模型性能的快速下降,甚至完全覆盖或遗忘以前学习到的旧知识。 为了克服灾难性遗忘,我们希望模型一方面必须表现出从新数据中整合新知识和提炼已有知识的能力(可塑性),另一方面又必须防止新输入对已有知识的显著干扰(稳定性) 这两个互相冲突的需求构成了所谓的 稳定性-可塑性困境(stability-plasticity dilemma) 增量学习目前还没有一个特别清晰的定义,因此比较容易与在线学习,迁移学习和多任务学习等概念混淆, 尤其要注意增量学习和在线学习的区别,在线学习通常要求每个样本只能使用一次,且数据全都来自于同一个任务,而增量学习是多任务的,但它允许在进入下一个任务之前多次处理当前任务的数据。 增量学习主要关注的是灾难性遗忘（Catastrophic forgetting），平衡新知识与旧知识之间的关系，即如何在学习新知识的情况下不忘记旧知识。引用Robipolikar对增量学习算法的定义,即一个增量学习算法应同时具有以下特点:1） 可以从新数据中学习新知识2） 以前已经处理过的数据不需要重复处理3） 每次只有一个训练观测样本被看到和学习4） 学习新知识的同时能保持以前学习到的大部分知识5） 一旦学习完成后训练观测样本被丢弃6） 学习系统没有关于整个训练样本的先验知识 迁移学习迁移学习是指用已存有的知识对不同但相关领域问题进行求解的一种机器学习方法。这里迁移学习放宽了上面的两个基本假设，我们可以迁移已有的知识来解决目标领域中仅有少量有标签样本数据甚至没有学习样本的问题。（当然了，目标领域样本量肯定是越多越好的）。当不同元素共享的因素越多，迁移学习就越容易，就好像你学会了骑自行车，可能就很容易学会骑摩托车，但是学会骑自行车再去骑三轮车，可能就会很不适应。（亲身经历，确实如此，三轮车每次拐弯的时候，可能时因为重心的位置与自行车不一样，总有一种要翻车的感觉，很容易失去平衡）","link":"/2021/11/01/paperNote/"},{"title":"","text":"了解了增量学习和锚框的概念。 增量学习测试一下在传统分类任务中，为了保证训练得到的分类模型具有准确性和高可靠性，由两个基本假设:1.学习的训练样本和新的测试样本满足独立同分布2.必须有足够可用的训练样本 增量学习的能力就是能够不断地处理现实世界中连续的信息流,在吸收新知识的同时保留甚至整合 优化旧知识的能力。 造成灾难性遗忘的一个主要原因是 传统模型假设数据分布是固定或平稳的,训练样本是独立同分布的 ,所以模型可以一遍又一遍地看到所有任务相同的数据,但当数据变为连续的数据流时,训练数据的分布就是非平稳的,模型从非平稳的数据分布中持续不断地获取知识时,新知识会干扰旧知识,从而导致模型性能的快速下降,甚至完全覆盖或遗忘以前学习到的旧知识。 为了克服灾难性遗忘,我们希望模型一方面必须表现出从新数据中整合新知识和提炼已有知识的能力(可塑性),另一方面又必须防止新输入对已有知识的显著干扰(稳定性) 这两个互相冲突的需求构成了所谓的 稳定性-可塑性困境(stability-plasticity dilemma) 增量学习目前还没有一个特别清晰的定义,因此比较容易与在线学习,迁移学习和多任务学习等概念混淆, 尤其要注意增量学习和在线学习的区别,在线学习通常要求每个样本只能使用一次,且数据全都来自于同一个任务,而增量学习是多任务的,但它允许在进入下一个任务之前多次处理当前任务的数据。 增量学习主要关注的是灾难性遗忘（Catastrophic forgetting），平衡新知识与旧知识之间的关系，即如何在学习新知识的情况下不忘记旧知识。引用Robipolikar对增量学习算法的定义,即一个增量学习算法应同时具有以下特点:1） 可以从新数据中学习新知识2） 以前已经处理过的数据不需要重复处理3） 每次只有一个训练观测样本被看到和学习4） 学习新知识的同时能保持以前学习到的大部分知识5） 一旦学习完成后训练观测样本被丢弃6） 学习系统没有关于整个训练样本的先验知识 迁移学习迁移学习是指用已存有的知识对不同但相关领域问题进行求解的一种机器学习方法。这里迁移学习放宽了上面的两个基本假设，我们可以迁移已有的知识来解决目标领域中仅有少量有标签样本数据甚至没有学习样本的问题。（当然了，目标领域样本量肯定是越多越好的）。当不同元素共享的因素越多，迁移学习就越容易，就好像你学会了骑自行车，可能就很容易学会骑摩托车，但是学会骑自行车再去骑三轮车，可能就会很不适应。（亲身经历，确实如此，三轮车每次拐弯的时候，可能时因为重心的位置与自行车不一样，总有一种要翻车的感觉，很容易失去平衡）","link":"/2022/07/03/papertest/"}],"tags":[{"name":"note","slug":"note","link":"/tags/note/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"study","slug":"study","link":"/tags/study/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}